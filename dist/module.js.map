{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./module.ts","webpack:///./datasource.ts","webpack:///./query_ctrl.ts","webpack:///external \"app/plugins/sdk\"","webpack:///./config_ctrl.ts","webpack:///./query_options_ctrl.ts","webpack:///./annotation_ctrl.ts"],"names":["installedModules","__webpack_require__","m","i","Datasource","DarkSkyDatasource","QueryCtrl","DarkSkyQueryCtrl","ConfigCtrl","DarkSkyConfigCtrl","QueryOptionsCtrl","DarkskyQueryOptionsCtrl","AnnotationsQueryCtrl","DarkSkyAnnotationCtrl","metricFindQuery","this","metrics","props","key","query","r","options","targets","a","range","map","buildQueryParameters","t","target","resHeaders","backendSrv","instanceSettings","config","getOptions","refresh","templateSrv","module","e","c","d","exports","name","getter","o","Object","defineProperty","enumerable","get","Symbol","toStringTag","value","mode","__esModule","ns","create","bind","n","object","property","prototype","hasOwnProperty","call","p","s","moduleId","l","modules"],"mappings":"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","file":"module.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import { DarkSkyDatasource } from './datasource';\nimport { DarkSkyQueryCtrl } from './query_ctrl';\nimport { DarkSkyConfigCtrl } from './config_ctrl';\nimport { DarkskyQueryOptionsCtrl } from './query_options_ctrl';\nimport { DarkSkyAnnotationCtrl } from './annotation_ctrl';\n\nexport {\n  DarkSkyDatasource as Datasource,\n  DarkSkyQueryCtrl as QueryCtrl,\n  DarkSkyConfigCtrl as ConfigCtrl,\n  DarkskyQueryOptionsCtrl as QueryOptionsCtrl,\n  DarkSkyAnnotationCtrl as AnnotationsQueryCtrl,\n};\n","import _ from 'lodash';\n\ntype ApiCallDefinition = {\n  dataset: string,\n  timestamps: number[],\n};\n\ntype Metric = {\n  text: string,\n  value: string,\n};\n\nexport class DarkSkyDatasource {\n\n  datasourceName: string;\n  apiUrl: string;\n  apiOptions: string;\n  metrics: Metric[];\n  lat: number;\n  lon: number;\n  /** @ngInject **/\n  constructor(instanceSettings, private backendSrv, private templateSrv, private $q) {\n    this.datasourceName = instanceSettings.name;\n\n    const config = instanceSettings.jsonData;\n    this.lat = config.lat;\n    this.lon = config.lon;\n    const credentials = `${config.apikey}`;\n    this.apiUrl = `/api/datasources/proxy/${instanceSettings.id}/darksky/${credentials}`;\n    this.apiOptions = `units=${config.unit}&lang=${config.language}`;\n  }\n\n  metricFindQuery(query) {\n    // cache metrics query\n    if (this.metrics) {\n      return this.metrics;\n    }\n    return this.doRequest({\n      query,\n      url: `${this.apiUrl}/${this.lat}, ${this.lon}`,\n      method: 'GET',\n    }).then((res: any) => {\n      // get all properties from forecast query\n      const datasets = ['currently', /*'minutely',*/ 'hourly', 'daily'];\n      const metrics = _.transform(datasets, (metrics, dataset) => {\n        let props = res.data[dataset];\n        if (props && _.isArray(props.data)) {\n          props = props.data.length ? props.data[0] : {};\n        }\n        metrics.push(..._.filter(_.keys(props), key => key !== 'time'));\n      }, [] as string[]);\n\n      this.metrics = _.map(_.uniq(_.sortBy(metrics)), metric => ({\n        text: metric,\n        value: metric,\n      }));\n\n      return this.metrics;\n    });\n  }\n\n  query(options) {\n    let query = this.buildQueryParameters(options);\n    query.targets = query.targets.filter(t => !t.hide);\n\n    if (query.targets.length <= 0) {\n      return this.$q.when({ data: [] });\n    }\n\n    if (this.templateSrv.getAdhocFilters) {\n      query.adhocFilters = this.templateSrv.getAdhocFilters(this.datasourceName);\n    } else {\n      query.adhocFilters = [];\n    }\n\n    const apiCalls = this.getApiCalls(query.range, query.maxDataPoints);\n\n    let longi = this.lon;\n    let lati = this.lat;\n    if (options) {\n      if (options.targets) {\n        longi = options.targets[0].lon;\n        lati = options.targets[0].lat;\n      }\n    }\n    const url = `${this.apiUrl}/${lati},${longi}`;\n    const requests = _.map(apiCalls.timestamps, ts => this.doRequest({\n      query,\n      url: `${url},${ts}?${this.apiOptions}`,\n      method: 'GET',\n    }));\n\n    if (apiCalls.timestamps.length >= 10) {\n      console.warn(`DarkSky will execute ${apiCalls.timestamps.length} api.`);\n    }\n\n    return Promise.all(requests).then((response: any) => {\n      // extraxt data from json result structure\n      let data = _.transform(response, (data, res) => {\n        // select currently datapoint\n        const dataset = _.get(res, `data.${apiCalls.dataset}`);\n        if (apiCalls.dataset === 'currently') {\n          data.push(dataset);\n          return;\n        }\n\n        // select timestamps inside query range\n        data.push(..._.filter(dataset.data, (res: any) => {\n          const timeMS = res.time * 1000;\n          return timeMS >= query.range.from && timeMS <= query.range.to;\n        }));\n      }, [] as any[]);\n\n      // sort by timestamp\n      data = _.sortBy(data, 'time');\n\n      // table query?\n      return (_.filter(query.targets, { type: 'table' }).length)\n        ? this.tableResponse(query.targets, data)\n        : this.timeseriesResponse(query.targets, data);\n    });\n  }\n\n  getApiCalls(range, maxDataPoints): ApiCallDefinition {\n    let dataset = 'hourly', step = 1;\n    const hours = range.to.diff(range.from, 'hours');\n\n    const date = range.from.clone().startOf('day');\n    const timestamps: any[] = [date.unix()];\n\n    // not same day?\n    if (range.to.date() !== range.from.date()) {\n      if (hours > 7 * 24) { // daily queries - daily\n        dataset = 'daily';\n        if (maxDataPoints) { // limit number of queries\n          const days = range.to.diff(range.from, 'days');\n          step = Math.max(step, Math.floor(days / maxDataPoints));\n        }\n      }\n\n      // create one timestamp per additional day\n      date.add(step, 'day');\n      while (date.isBefore(range.to)) {\n        timestamps.push(date.unix());\n        date.add(step, 'day');\n      }\n    }\n\n    return {\n      dataset: dataset,\n      timestamps: timestamps,\n    };\n  }\n\n  tableResponse(targets, data) {\n    // use first metric for table query\n\n    const columns = _.map(_.head(data) as any, (val, key) => ({\n      text: key,\n      type: (key.match(/[Tt]ime/)) ? 'time' : (typeof (val) === 'string' ? 'string' : 'number'),\n    }));\n\n    const rows = _.map(data, (row: any) => {\n      return _.map(columns as any[], (col: any) => {\n        if (row[col.text] === undefined) return null;\n\n        // time to millisec\n        return col.type === 'time' ? row[col.text] * 1000 : row[col.text];\n      });\n    });\n\n    return {\n      data: [{\n        type: 'table',\n        columns: columns,\n        rows: rows,\n      }],\n    };\n  }\n\n  timeseriesResponse(targets, data) {\n    const res = {\n      data: _.map(targets, target => ({\n        target: target.target,\n        datapoints: _.map(data, d => [d[target.target], d.time * 1000]),\n      })),\n    };\n\n    return res;\n  }\n\n  buildQueryParameters(options) {\n    // remove placeholder targets\n    options.targets = _.filter(options.targets, target => target.target !== 'select metric');\n    // apply variables\n    options.targets = _.map(options.targets, target => ({\n      target: this.templateSrv.replace(target.target, options.scopedVars, 'regex'),\n      refId: target.refId,\n      hide: target.hide,\n      type: target.type,\n      lon: target.lon,\n      lat: target.lat,\n    }));\n    return options;\n  }\n\n  testDatasource() {\n    return this.doRequest({}).then(response => (response.status === 200)\n      ? { status: 'success', message: 'Data source is working', title: 'Success' }\n      : { status: 'error', message: `Data source returned status ${response.status}`, title: 'Error' },\n    );\n  }\n\n  doRequest(options) {\n    // call with pre-defined default options\n    const url = `${this.apiUrl}/${this.lat}, ${this.lon}`;\n    if (options) {\n      if (!options.url) {\n        console.log('set default url, since no url is given');\n        options.url = url;\n      }\n    }\n    return this.backendSrv.datasourceRequest(options).then((response: any) => {\n      let resHeaders = _.get(response, 'headers');\n      if (!resHeaders) {\n        console.warn('No headers found!');\n      } else {\n        let calls = 0;\n        if (typeof resHeaders === 'function') {\n          resHeaders = resHeaders();\n          calls = _.get(resHeaders, 'x-forecast-api-calls');\n        } else {\n          calls = resHeaders.get('x-forecast-api-calls');\n        }\n        if (calls > 600) {\n          console.warn(`DarkSky noticed you've already executed ${calls} api calls. Free limit is 1000.`);\n        }\n      }\n      return response;\n    });\n  }\n\n  annotationQuery(options) {\n    throw new Error('Annotation Support not implemented yet.');\n  }\n}\n","import { QueryCtrl } from 'grafana/app/plugins/sdk';\n// import './css/query-editor.css!'\n\nexport class DarkSkyQueryCtrl extends QueryCtrl {\n  static templateUrl = 'partials/query.editor.html';\n\n  private types: { text: string, value: string }[];\n  private lon: number;\n  private lat: number;\n\n  /** @ngInject **/\n  constructor($scope, $injector, private templateSrv) {\n    super($scope, $injector);\n\n    this.types = [{ text: 'Time series', value: 'timeseries' }, { text: 'Table', value: 'table' }];\n\n    this.target.target = this.target.target || 'select metric';\n    this.target.type = this.target.type || ((this.panelCtrl.panel.type === 'table') ? 'table' : 'timeseries');\n    this.target.lon = this.target.lon || this.datasource.lon;\n    this.target.lat = this.target.lat || this.datasource.lat;\n  }\n\n  getOptions(query) {\n    return this.datasource.metricFindQuery(this.target.type);\n  }\n\n  refresh() {\n    this.panelCtrl.refresh(); // Asks the panel to refresh data.\n  }\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__4__;","export class DarkSkyConfigCtrl {\n  static templateUrl = 'partials/config.html';\n\n  current: any;\n  private units: { name: string, value: string }[];\n  private languages: { name: string, value: string }[];\n\n  /** @ngInject **/\n  constructor($scope) {\n    console.debug('DarkSkyConfigCtrl');\n\n    this.units = [\n      { name: 'SI', value: 'si' },\n      { name: 'Auto', value: 'auto' },\n      { name: 'US', value: 'us' },\n      { name: 'CA', value: 'ca' },\n      { name: 'UK', value: 'uk2' },\n    ];\n\n    this.languages = [\n      { name: 'Arabic', value: 'ar' },\n      { name: 'Azerbaijani', value: 'az' },\n      { name: 'Belarusian', value: 'be' },\n      { name: 'Bulgarian', value: 'bg' },\n      { name: 'Bosnian', value: 'bs' },\n      { name: 'Catalan', value: 'ca' },\n      { name: 'Czech', value: 'cs' },\n      { name: 'Danish', value: 'da' },\n      { name: 'German', value: 'de' },\n      { name: 'Greek', value: 'el' },\n      { name: 'English', value: 'en' },\n      { name: 'Spanish', value: 'es' },\n      { name: 'Estonian', value: 'et' },\n      { name: 'Finnish', value: 'fi' },\n      { name: 'French', value: 'fr' },\n      { name: 'Hebrew', value: 'he' },\n      { name: 'Croatian', value: 'hr' },\n      { name: 'Hungarian', value: 'hu' },\n      { name: 'Indonesian', value: 'id' },\n      { name: 'Icelandic', value: 'is' },\n      { name: 'Italian', value: 'it' },\n      { name: 'Japanese', value: 'ja' },\n      { name: 'Georgian', value: 'ka' },\n      { name: 'Korean', value: 'ko' },\n      { name: 'Cornish', value: 'kw' },\n      { name: 'Norwegian', value: 'nb' },\n      { name: 'Dutch', value: 'nl' },\n      { name: 'Polish', value: 'pl' },\n      { name: 'Portuguese', value: 'pt' },\n      { name: 'Romanian', value: 'ro' },\n      { name: 'Russian', value: 'ru' },\n      { name: 'Slovak', value: 'sk' },\n      { name: 'Slovenian', value: 'sl' },\n      { name: 'Serbian', value: 'sr' },\n      { name: 'Swedish', value: 'sv' },\n      { name: 'Tetum', value: 'tet' },\n      { name: 'Turkish', value: 'tr' },\n      { name: 'Ukrainian', value: 'uk' },\n      { name: 'Chinese', value: 'zh' },\n    ];\n\n    this.current.jsonData.unit = this.current.jsonData.unit || 'si';\n    this.current.jsonData.language = this.current.jsonData.language || 'en';\n  }\n}\n","export class DarkskyQueryOptionsCtrl {\n  static templateUrl = 'partials/query.options.html';\n\n  /** @ngInject **/\n  constructor($scope) {\n    console.debug('DarkSkyQueryOptionsCtrl');\n  }\n}\n","export class DarkSkyAnnotationCtrl {\n  static templateUrl = 'partials/annotations.editor.html';\n\n  /** @ngInject **/\n  constructor($scope) {\n    console.debug('DarkSkyAnnotationCtrl');\n  }\n}\n"],"sourceRoot":""}